<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- twitter -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:site" content="@codenlighten1" />
    <meta name="twitter:creator" content="@codenlighten1" />
    <meta name="twitter:title" content="Bitcoin Script Builder" />
    <meta
      name="twitter:description"
      content="This tool allows you to build a script using a stack. The locking script is used to lock funds to an address. The locking script is also known as a scriptPubKey. The stack structure and OP CODES are modeled after the Forth programming language. The stack is a LIFO (last in first out) data structure. The Locking Script and Unlocking Script are combined to create a combined script. The combined script is evaluated to determine if the funds can be spent. If the combined script evaluates to true, the funds can be spent."
    />
    <!-- https://plugins.whatsonchain.com/api/plugin/main/ab96e7be2830655dcffa6c8ca2b64c6a9da7c919c19f9bb6c433da75dc235a85/0 -->
    <meta
      name="twitter:image"
      content="https://plugins.whatsonchain.com/api/plugin/main/ab96e7be2830655dcffa6c8ca2b64c6a9da7c919c19f9bb6c433da75dc235a85/0"
    />
    <!-- favicon  -->
    <link
      rel="icon"
      href="https://plugins.whatsonchain.com/api/plugin/main/ab96e7be2830655dcffa6c8ca2b64c6a9da7c919c19f9bb6c433da75dc235a85/0"
    />
    <script src="https://unpkg.com/bsv@1.5"></script>
    <script src="https://cdn.jsdelivr.net/npm/bsv@1.5.0/bsv-message.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bsv@1.5.0/bsv-mnemonic.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bsv@1.5.0/bsv-ecies.min.js"></script>
    <title>Bitcoin SV Locking Script Examples</title>
    <style>
      * {
        box-sizing: border-box;
      }

      body {
        font-family: "Arial", sans-serif;
        background-color: #f4f4f4;
        color: #333;
        line-height: 1.6;
        word-wrap: break-word;
      }

      .container {
        background-color: #fff;
        padding: 20px;
        border: 1px solid #ddd;
        margin: 20px auto;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        max-width: 900px;
      }

      h1,
      h2 {
        color: #333;
      }

      button,
      input,
      select {
        font-family: inherit;
        font-size: 16px;
        padding: 10px;
        margin: 5px 0;
        border: 1px solid #ddd;
        border-radius: 5px;
      }

      button {
        background-color: #5c9ccf;
        color: white;
        border: none;
      }

      button:hover {
        background-color: #4a8cbd;
        cursor: pointer;
      }

      #stack div,
      #lockResults {
        cursor: pointer;
        transition: background-color 0.3s ease;
      }

      #stack div:hover,
      #lockResults:hover,
      button:hover {
        background-color: #eee;
        color: #333;
      }
      #logo {
        width: 100%;
        max-width: 300px;
        display: block;
        margin: 0 auto;
      }

      #header {
        text-align: center;
      }

      #myKeys {
        text-align: left;
      }

      textarea {
        width: 100%;
        max-width: 100%;
        height: 100px;
        max-height: 100px;
      }

      @media (max-width: 600px) {
        .container {
          width: 90%;
          padding: 10px;
        }

        #stack div,
        #opcodeSelect,
        #data,
        #file,
        #amount,
        #receiver {
          width: 100%;
          max-width: none;
        }
      }
    </style>
  </head>
  <body>
    <div class="container" id="header">
      <img
        src="https://plugins.whatsonchain.com/api/plugin/main/ab96e7be2830655dcffa6c8ca2b64c6a9da7c919c19f9bb6c433da75dc235a85/0"
        alt=""
        id="logo"
      />
      <p>
        <!-- describe how it uses forth like stack -->
        This tool allows you to build a bitcoin non-standard script using a
        stack. The locking script is used to lock funds to an address or other
        conditions. The locking script is also known as a scriptPubKey. The
        stack structure and OP CODES are modeled after the Forth programming
        language. The stack is a LIFO (last in first out) data structure. The
        Locking Script and Unlocking Script are combined to create a combined
        script. The combined script is evaluated to determine if the funds can
        be spent. If the combined script evaluates to true, the funds can be
        unlocked and spent.
      </p>
    </div>
    <div class="container" id="myKeys">
      <h2>My Keys</h2>
      <p>
        The following keys are used in the examples. The private keys are
        generated from the mnemonic phrase using the BSV library.
      </p>
      <p><strong>Mnemonic Phrase:</strong> <span id="mnemonic"></span></p>
      <p><strong>Private Key:</strong> <span id="privateKey"></span></p>
      <p><strong>Public Key:</strong> <span id="publicKey"></span></p>
      <p><strong>Address:</strong> <span id="address"></span></p>
      <p><strong>Balance:</strong> <span id="balance"></span></p>
    </div>
    <div class="container" id="importMnemonic">
      <h2>Import Mnemonic Phrase</h2>
      <!-- input -->
      <p><strong>Enter Mnemonic Phrase:</strong></p>
      <input type="text" id="mnemonicInput" />
      <button id="importMnemonic">Import Mnemonic</button>
    </div>
    <div class="container" id="recipientAddress">
      <h2>Recipient Keys</h2>
      <p>
        The following address is used as the recipient address in the examples.
      </p>
      <p><strong>Address:</strong> <span id="recipient"></span></p>
      <!-- privateKey -->
      <!-- publicKey -->
      <p><strong>Private Key</strong> <span id="recipientPrivateKey"></span></p>
      <p><strong>Public Key</strong> <span id="recipientPublicKey"></span></p>
    </div>

    <div class="container" id="examples">
      <h2>Add Stack Item</h2>
      <select name="" id="opcodeSelect">
        <option value="">Choose OpCode</option>
        <option value="OP_0">OP_0</option>
        <option value="OP_1">OP_1</option>
        <option value="OP_2">OP_2</option>
        <option value="OP_3">OP_3</option>
        <option value="OP_4">OP_4</option>
        <option value="OP_5">OP_5</option>
        <option value="OP_6">OP_6</option>
        <option value="OP_7">OP_7</option>
        <option value="OP_8">OP_8</option>
        <option value="OP_9">OP_9</option>
        <option value="OP_10">OP_10</option>
        <option value="OP_11">OP_11</option>
        <option value="OP_12">OP_12</option>
        <option value="OP_13">OP_13</option>
        <option value="OP_14">OP_14</option>
        <option value="OP_15">OP_15</option>
        <option value="OP_16">OP_16</option>
        <option value="OP_1NEGATE">OP_1NEGATE</option>
        <option value="OP_1ADD">OP_1ADD</option>
        <option value="OP_1SUB">OP_1SUB</option>
        <option value="OP_2DIV">OP_2DIV</option>
        <option value="OP_2DROP">OP_2DROP</option>
        <option value="OP_2DUP">OP_2DUP</option>
        <option value="OP_2MUL">OP_2MUL</option>
        <option value="OP_2OVER">OP_2OVER</option>
        <option value="OP_2ROT">OP_2ROT</option>
        <option value="OP_2SWAP">OP_2SWAP</option>
        <option value="OP_3DUP">OP_3DUP</option>
        <option value="OP_ABS">OP_ABS</option>
        <option value="OP_ADD">OP_ADD</option>
        <option value="OP_AND">OP_AND</option>
        <!-- bin2num -->
        <option value="OP_BIN2NUM">OP_BIN2NUM</option>
        <option value="OP_BOOLAND">OP_BOOLAND</option>
        <option value="OP_BOOLOR">OP_BOOLOR</option>
        <option value="OP_CAT">OP_CAT</option>
        <option value="OP_CHECKMULTISIG">OP_CHECKMULTISIG</option>
        <option value="OP_CHECKMULTISIGVERIFY">OP_CHECKMULTISIGVERIFY</option>
        <option value="OP_CHECKSIG">OP_CHECKSIG</option>
        <option value="OP_CHECKSIGVERIFY">OP_CHECKSIGVERIFY</option>
        <option value="OP_CODESEPARATOR">OP_CODESEPARATOR</option>
        <option value="OP_DEPTH">OP_DEPTH</option>
        <option value="OP_DIV">OP_DIV</option>
        <option value="OP_DROP">OP_DROP</option>
        <option value="OP_DUP">OP_DUP</option>
        <option value="OP_ELSE">OP_ELSE</option>
        <option value="OP_ENDIF">OP_ENDIF</option>
        <option value="OP_EQUAL">OP_EQUAL</option>
        <option value="OP_EQUALVERIFY">OP_EQUALVERIFY</option>
        <option value="OP_FALSE">OP_FALSE</option>
        <option value="OP_FROMALTSTACK">OP_FROMALTSTACK</option>
        <option value="OP_GREATERTHAN">OP_GREATERTHAN</option>
        <option value="OP_GREATERTHANOREQUAL">OP_GREATERTHANOREQUAL</option>
        <option value="OP_HASH160">OP_HASH160</option>
        <option value="OP_HASH256">OP_HASH256</option>
        <option value="OP_IF">OP_IF</option>
        <option value="OP_IFDUP">OP_IFDUP</option>
        <option value="OP_INVALIDOPCODE">OP_INVALIDOPCODE</option>
        <option value="OP_INVERT">OP_INVERT</option>
        <option value="OP_LEFT">OP_LEFT</option>
        <option value="OP_LESSTHAN">OP_LESSTHAN</option>
        <option value="OP_LESSTHANOREQUAL">OP_LESSTHANOREQUAL</option>
        <option value="OP_LSHIFT">OP_LSHIFT</option>
        <option value="OP_MAX">OP_MAX</option>
        <option value="OP_MIN">OP_MIN</option>
        <option value="OP_MOD">OP_MOD</option>
        <option value="OP_MUL">OP_MUL</option>
        <option value="OP_NEGATE">OP_NEGATE</option>
        <option value="OP_NIP">OP_NIP</option>
        <option value="OP_NOP">OP_NOP</option>
        <option value="OP_NOP1">OP_NOP1</option>
        <option value="OP_NOP10">OP_NOP10</option>
        <option value="OP_NOP2">OP_NOP2</option>
        <option value="OP_NOP3">OP_NOP3</option>
        <option value="OP_NOP4">OP_NOP4</option>
        <option value="OP_NOP5">OP_NOP5</option>
        <option value="OP_NOP6">OP_NOP6</option>
        <option value="OP_NOP7">OP_NOP7</option>
        <option value="OP_NOP8">OP_NOP8</option>
        <option value="OP_NOP9">OP_NOP9</option>
        <option value="OP_NOT">OP_NOT</option>
        <option value="OP_NOTIF">OP_NOTIF</option>
        <option value="OP_NUMEQUAL">OP_NUMEQUAL</option>
        <option value="OP_NUMEQUALVERIFY">OP_NUMEQUALVERIFY</option>
        <option value="OP_NUMNOTEQUAL">OP_NUMNOTEQUAL</option>
        <!-- num2bin -->
        <option value="OP_NUM2BIN">OP_NUM2BIN</option>
        <option value="OP_OR">OP_OR</option>
        <option value="OP_OVER">OP_OVER</option>
        <option value="OP_PICK">OP_PICK</option>
        <option value="OP_PUSHDATA1">OP_PUSHDATA1</option>
        <option value="OP_PUSHDATA2">OP_PUSHDATA2</option>
        <option value="OP_PUSHDATA4">OP_PUSHDATA4</option>
        <!-- <option value="OP_RESERVED">OP_RESERVED</option>
        <option value="OP_RESERVED1">OP_RESERVED1</option>
        <option value="OP_RESERVED2">OP_RESERVED2</option> -->
        <option value="OP_RETURN">OP_RETURN</option>
        <option value="OP_RIGHT">OP_RIGHT</option>
        <option value="OP_RIPEMD160">OP_RIPEMD160</option>
        <option value="OP_ROLL">OP_ROLL</option>
        <option value="OP_ROT">OP_ROT</option>
        <option value="OP_RSHIFT">OP_RSHIFT</option>
        <option value="OP_SHA1">OP_SHA1</option>
        <option value="OP_SHA256">OP_SHA256</option>
        <option value="OP_SIZE">OP_SIZE</option>
        <option value="OP_SUB">OP_SUB</option>
        <option value="OP_SUBSTR">OP_SUBSTR</option>
        <option value="OP_SWAP">OP_SWAP</option>
        <option value="OP_TOALTSTACK">OP_TOALTSTACK</option>
        <option value="OP_TRUE">OP_TRUE</option>
        <option value="OP_TUCK">OP_TUCK</option>
        <!-- <option value="OP_VER">OP_VER</option>
        <option value="OP_VERIF">OP_VERIF</option>
        <option value="OP_VERIFY">OP_VERIFY</option>
        <option value="OP_VERNOTIF">OP_VERNOTIF</option> -->
        <option value="OP_WITHIN">OP_WITHIN</option>
        <option value="OP_XOR">OP_XOR</option>
        <!-- 1 through 76 -->
      </select>
      <button id="addOpCode">Add OpCode</button>
      <button id="p2pkh">P2PKH</button>
      <!-- add data -->
      <p>Add Data</p>
      <!-- checkbox turn off alerts -->
      <!-- textarea -->
      <textarea
        placeholder="data"
        name=""
        id="data"
        cols="30"
        rows="10"
      ></textarea>
      <!-- file -->
      <p>Upload File</p>
      <input type="file" id="file" />
      <div class="buttons">
        <button id="addData">Add Plain Data</button>
        <button id="addHashData">Add Hash of Data (OP_SHA256)</button>
        <!-- double hash -->
        <button id="addDoubleHashData">
          Add Double Hash of Data (OP_HASH256)
        </button>
        <!-- add signature of current stack -->
        <button id="addSignature">Add Signature of Current Stack</button>
      </div>

      <div class="alerts">
        <input type="checkbox" id="alertCheck" />
        <label for="alertCheck">Turn on alerts</label>
      </div>

      <!-- add number -->
      <p>Add Number</p>
      <input placeholder="number" type="number" id="number" />
      <button id="addNumber">Add Number</button>
      <p>Add Address of Recipient for PKH</p>
      <input placeholder="change receiever" type="text" id="receiver" />
      <!-- amount -->
      <p>Amount of Satoshis to Lock</p>
      <input value="1" type="text" id="amount" />
      <!-- addPubkey -->
      <p>Choose nLocktime</p>
      <input value="0" type="text" id="nLocktime" />
      <div class="sigHashFlag">
        <select name="" id="sighashSelect">
          <option value="null">Choose Sighash Flag</option>
          <option value="SIGHASH_NONE">SIGHASH_NONE</option>
          <option value="SIGHASH_ALL">SIGHASH_ALL</option>
          <option value="SIGHASH_SINGLE">SIGHASH_SINGLE</option>
        </select>
      </div>
      <div class="buttons">
        <button id="addCurrentPreimage">Add Current Preimage</button>
        <button id="addPubKey">Add Recipient(PK)</button>
        <button id="addPubKeyHash">Add Recipient(PKHash)</button>
        <button id="broadcast">Generate Broadcast Script</button>
      </div>

      <!-- checkbox for redeem script check-->
      <div class="alerts">
        <input type="checkbox" id="redeemCheck" />
        <label for="redeemCheck">Redeem Script Check</label>
      </div>
    </div>
    <div class="container" id="currentStack">
      <h2>Current Stack</h2>
      <p><strong>Stack:</strong> <span id="stack"></span></p>
    </div>
    <div class="container" id="currentLockScript">
      <h2>Current Locking Script</h2>
      <p><strong>Hex:</strong> <span id="hex"></span></p>
      <p><strong>Asm:</strong> <span id="asm"></span></p>
      <p><strong>Binary:</strong> <span id="binary"></span></p>
    </div>
    <div class="container" id="finalScript">
      <h2>Final Script</h2>

      <button style="display: none" id="genBroadcast">Broadcast TX</button>
      <p id="lockResults" title="click to copy"></p>
      <p id="preimage"></p>
    </div>
    <div class="container" id="redeemLock">
      <h2>Redeem a Locking Script</h2>
      <p><strong>Enter Transaction ID to Redeem:</strong></p>
      <input type="text" id="txidInput" />
      <button id="redeem">Redeem</button>
      <div id="currentLock"></div>
      <div id="currentUnlock"></div>
      <div id="combinedScript"></div>
    </div>
    <div class="container" id="copyright2023">
      <p>&copy; 2023 CodenLighten. All Rights Reserved</p>
    </div>
    <script>
      let currentUtxos = [];
      // current preimage
      let currentPreimage = "";
      let currentLockingScript = "";
      let redeemScriptCheck = false;

      let sighashType =
        bsv.crypto.Signature.SIGHASH_ALL | bsv.crypto.Signature.SIGHASH_FORKID;
      const Buffer = bsv.deps.Buffer;
      const path = "m/44'/0'/0'/0/0";
      const generateKeys = () => {
        const mnemonic = bsvMnemonic.fromRandom();
        const seed = mnemonic.toSeed();
        const root = bsv.HDPrivateKey.fromSeed(seed);
        const child = root.deriveChild(path);
        const privateKey = child.privateKey;
        const publicKey = bsv.PublicKey.fromPrivateKey(privateKey);
        const address = bsv.Address.fromPublicKey(publicKey);

        return {
          mnemonic: mnemonic.toString(),
          privateKey: privateKey.toString(),
          publicKey: publicKey.toString(),
          address: address.toString(),
        };
      };
      document
        .getElementById("importMnemonic")
        .addEventListener("click", () => {
          const mnemonic = document.getElementById("mnemonicInput").value;
          //   from mnemonic string
          const mnemonic2 = bsvMnemonic.fromString(mnemonic);
          const seed = mnemonic2.toSeed();
          const root = bsv.HDPrivateKey.fromSeed(seed);
          const child = root.deriveChild(path);
          const privateKey = child.privateKey;
          const publicKey = bsv.PublicKey.fromPrivateKey(privateKey);
          const address = bsv.Address.fromPublicKey(publicKey);
          const keys = {
            mnemonic: mnemonic,
            privateKey: privateKey.toString(),
            publicKey: publicKey.toString(),
            address: address.toString(),
          };
          localStorage.setItem("keys", JSON.stringify(keys));
          //display keys
          document.getElementById("mnemonic").innerHTML = keys.mnemonic;
          document.getElementById("privateKey").innerHTML = keys.privateKey;
          document.getElementById("publicKey").innerHTML = keys.publicKey;
          document.getElementById("address").innerHTML = keys.address;

          getBalance(keys.address).then((balance) => {
            document.getElementById("balance").innerHTML = balance.balance;
          });
        });

      const getBalance = async (address) => {
        const utxos = await fetch(
          `https://api.bitails.io/address/${address}/unspent`
        );
        const res = await utxos.json();
        const outputs = res.unspent;
        console.log(outputs);
        const balance = outputs.reduce((acc, output) => {
          return acc + output.satoshis;
        }, 0);

        return { balance };
      };
      //onload
      let keys;
      let recipientKeys;
      document.addEventListener("DOMContentLoaded", async () => {
        if (localStorage.getItem("keys")) {
          keys = JSON.parse(localStorage.getItem("keys"));
        }
        if (localStorage.getItem("recipientKeys")) {
          recipientKeys = JSON.parse(localStorage.getItem("recipientKeys"));
        }
        if (!keys) {
          keys = generateKeys();
          recipientKeys = generateKeys();
          localStorage.setItem("keys", JSON.stringify(keys));
          localStorage.setItem("recipientKeys", JSON.stringify(recipientKeys));
        }
        if (!recipientKeys) {
          recipientKeys = generateKeys();
          localStorage.setItem("recipientKeys", JSON.stringify(recipientKeys));
        }
        //display keys
        document.getElementById("mnemonic").innerHTML = keys.mnemonic;
        document.getElementById("privateKey").innerHTML = keys.privateKey;
        document.getElementById("publicKey").innerHTML = keys.publicKey;
        document.getElementById("address").innerHTML = keys.address;
        document.getElementById("recipient").innerHTML = recipientKeys.address;
        document.getElementById("receiver").value = recipientKeys.address;
        //display balance
        const { balance } = await getBalance(keys.address);
        document.getElementById("balance").innerHTML = balance;
        //display recipient keys
        document.getElementById("recipientPrivateKey").innerHTML =
          recipientKeys.privateKey;
        document.getElementById("recipientPublicKey").innerHTML =
          recipientKeys.publicKey;
      });
      const getUtxos = async (addy) => {
        const response = await fetch(
          `https://api.bitails.io/address/${addy}/unspent`
        );
        const res = await response.json();
        const unspent = res.unspent;
        const scripthash = res.scripthash;
        console.log(unspent);
        console.log(scripthash);
        const utxos = unspent.map((utxo) => {
          return {
            txid: utxo.txid,
            vout: utxo.vout,
            script: bsv.Script.buildPublicKeyHashOut(addy).toHex(),
            satoshis: utxo.satoshis,
          };
        });
        return utxos;
      };

      const getUtxosWhatsOnchain = async (addy) => {
        const response = await fetch(
          `https://api.whatsonchain.com/v1/bsv/main/address/${addy}/unspent`
        );
        const res = await response.json();

        const utxos = res.map((utxo) => {
          return {
            txid: utxo.tx_hash,
            vout: utxo.tx_pos,
            script: bsv.Script.buildPublicKeyHashOut(addy).toHex(),
            satoshis: utxo.value,
          };
        });
        return utxos;
      };

      const broadcastTx = async (tx) => {
        //  whatsonchain
        const response = await fetch(
          `https://api.whatsonchain.com/v1/bsv/main/tx/raw`,
          {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({ txhex: tx }),
          }
        );
        const res = await response.json();
        console.log(res);
        return res;
      };

      let currentStack = [];

      // const hexToBinary = (hex) => {
      //   return parseInt(hex, 16).toString(2);
      // };
      const convertOptoHex = (opcode) => {
        let hex = opcode;
        if (opcode.includes("OP_")) {
          hex = opcode.replace("OP_", "0x");
        }
        return hex;
      };
      const addOpCode = () => {
        const opCode = document.getElementById("opcodeSelect").value;
        currentStack.push(opCode);
        // console.log(convertOptoHex(opCode));
        const hex = bsv.Script.fromASM(currentStack.join(" ")).toHex();
        const asm = bsv.Script.fromASM(currentStack.join(" ")).toASM();
        document.getElementById("hex").innerHTML = hex;
        document.getElementById("asm").innerHTML = asm;
        document.getElementById("binary").innerHTML = hexToBinary(hex);
        const stackEl = document.createElement("div");
        stackEl.innerHTML = opCode;
        document.getElementById("stack").appendChild(stackEl);
        stackEl.addEventListener("click", () => {
          //remove from stack
          const index = currentStack.indexOf(opCode);
          if (index > -1) {
            currentStack.splice(index, 1);
          }
          console.log(currentStack);
          //remove from stack display
          stackEl.remove();
          //update locking script
          const hex = bsv.Script.fromASM(currentStack.join(" ")).toHex();
          const asm = bsv.Script.fromASM(currentStack.join(" ")).toASM();
          document.getElementById("hex").innerHTML = hex;
          document.getElementById("asm").innerHTML = asm;
          document.getElementById("binary").innerHTML = hexToBinary(hex);
        });
      };
      //compress file to smaller size
      const compress = async (file, quality) => {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.readAsDataURL(file);
          reader.onload = (event) => {
            const img = new Image();
            img.src = event.target.result;
            img.onload = () => {
              const elem = document.createElement("canvas");
              const width = img.width;
              const height = img.height;
              elem.width = width;
              elem.height = height;
              const ctx = elem.getContext("2d");
              // img.width and img.height will give the original dimensions
              ctx.drawImage(img, 0, 0, width, height);
              ctx.canvas.toBlob(
                (blob) => {
                  resolve(blob);
                },
                "image/jpeg",
                quality
              );
            };
          };
        });
      };
      const extractFile = async (file) => {
        const reader = new FileReader();
        //extract hex from file
        reader.readAsArrayBuffer(file);
        return new Promise((resolve, reject) => {
          reader.onload = () => {
            const arrayBuffer = reader.result;
            const bytes = new Uint8Array(arrayBuffer);
            console.log(bytes.length);
            const hex = Buffer.from(bytes).toString("hex");
            //length in kilobytes
            const length = hex.length / 2 / 1024;
            console.log(length, "kb");
            resolve({ bytes, hex });
          };
        });
      };

      const numToHex = (num) => {
        if (num < 17) {
          return `OP_${num}`;
        } else if (num < 76) {
          return `0x${num.toString(16)}`;
        } else {
          // Convert to little-endian hexadecimal
          const numBuffer = Buffer.allocUnsafe(4); // Adjust buffer size based on the number's size
          numBuffer.writeInt32LE(num, 0);
          return numBuffer.toString("hex");
        }
      };

      const addNumber = () => {
        const number = parseInt(document.getElementById("number").value, 10);
        currentStack.push(numToHex(number));
        console.log(currentStack);
        const hex = bsv.Script.fromASM(currentStack.join(" ")).toHex();
        const asm = bsv.Script.fromASM(currentStack.join(" ")).toASM();
        document.getElementById("hex").innerHTML = hex;
        document.getElementById("asm").innerHTML = asm;
        document.getElementById("binary").innerHTML = hexToBinary(hex);
        console.log(hex);
        const stackEl = document.createElement("div");
        stackEl.innerHTML = number;
        document.getElementById("stack").appendChild(stackEl);
        stackEl.addEventListener("click", () => {
          // Remove from stack
          const index = currentStack.indexOf(numToHex(number));
          if (index > -1) {
            currentStack.splice(index, 1);
          }
          console.log(currentStack);
          // Remove from stack display
          stackEl.remove();
          // Update locking script
          const hex = bsv.Script.fromASM(currentStack.join(" ")).toHex();
          const asm = bsv.Script.fromASM(currentStack.join(" ")).toASM();
          document.getElementById("hex").innerHTML = hex;
          document.getElementById("asm").innerHTML = asm;
          document.getElementById("binary").innerHTML = hexToBinary(hex);
        });
      };

      // Additional function to convert hex to binary
      function hexToBinary(hexString) {
        return hexString
          .split("")
          .map((hexDigit) => {
            return parseInt(hexDigit, 16).toString(2).padStart(4, "0");
          })
          .join("");
      }

      // add number
      document.getElementById("addNumber").addEventListener("click", () => {
        addNumber();
      });

      let imageCheck = false;
      let textCheck = false;

      const addData = async () => {
        const alertCheck = document.getElementById("alertCheck").checked;
        let data = "";
        let bytes = [];
        const textData = document.getElementById("data").value;
        const fileData = document.getElementById("file").files[0];

        if (!textData && !fileData) {
          alert("Please enter data or upload a file");
          return;
        }
        if (textData && fileData) {
          alert("Please enter data or upload a file, not both");
          return;
        }
        if (textData) {
          data = textData.trim();
          textCheck = true;
        } else if (fileData) {
          //check if file is image
          const type = fileData.type;
          if (type.includes("image")) {
            imageCheck = true;
          }
          const { bytes, hex } = await extractFile(fileData);
          // data = hex;
          data = bytes;
          //compress file if user would like
          //if image and file size is greater than 100kb
          if (imageCheck && data.length / 2 / 1024 > 100) {
            if (
              confirm(
                "File is greater than 100kb, would you like to compress it?"
              ) === true
            ) {
              //determine compression percent from current stack
              let percent = 0.5;
              //choose percent based on ratio of 100kb to current file size
              const currentSize = data.length / 2 / 1024;
              percent = 100 / currentSize / 2;
              const blob = await compress(fileData, percent);
              const { bytes, hex } = await extractFile(blob);
              data = bytes;
            }
          }
        }
        const dataHex = Buffer.from(data).toString("hex");

        console.log(dataHex.length);
        const length = dataHex.length / 2;
        console.log(alertCheck);
        //check if current stack is empty or last item is not a push data op code
        if (
          (alertCheck && currentStack.length === 0) || //if alert check is true, don't alert
          (alertCheck &&
            !currentStack[currentStack.length - 1].includes("OP_PUSHDATA"))
        ) {
          let opCode = "OP_PUSHDATA1";

          console.log(length);
          // must be less than 4GB
          if (length < 76) {
            opCode = length;
            alert(
              `Data length is ${length} bytes, consider preceding this data with ${opCode}`
            );
          } else if (length > 76 && length < 256) {
            opCode = "OP_PUSHDATA1";
            alert(
              `Data length is ${length} bytes, consider preceding this data with OP_PUSHDATA1`
            );
          } else if (length < 256) {
            opCode = "OP_PUSHDATA2";
            alert(
              `Data length is ${length} bytes, consider preceding this data with OP_PUSHDATA2`
            );
            // 4GB
          } else if (length > 256 && length < 4294967296) {
            opCode = "OP_PUSHDATA4";
            alert(
              `Data length is ${length} bytes, consider preceding this data with OP_PUSHDATA4`
            );
          } else {
            alert("File too large");
            return;
          }
        }

        if (textCheck) {
          currentStack.push(dataHex);
          textCheck = false;
        } else {
          currentStack.push(dataHex);
          //change add data button to add data again
          document.getElementById("addData").innerHTML = "Add Data";
          //remove bg color
          document.getElementById("addData").style.backgroundColor = "";
        }
        console.log(currentStack);
        const hex = bsv.Script.fromASM(currentStack.join(" ")).toHex();
        const asm = bsv.Script.fromASM(currentStack.join(" ")).toASM();
        document.getElementById("hex").innerHTML = hex;
        document.getElementById("asm").innerHTML = asm;
        document.getElementById("binary").innerHTML = hexToBinary(hex);
        console.log(hex);
        // clear data input
        document.getElementById("data").value = "";
        document.getElementById("file").value = "";
        const stackEl = document.createElement("div");
        stackEl.innerHTML = dataHex;
        document.getElementById("stack").appendChild(stackEl);
        stackEl.addEventListener("click", () => {
          //remove from stack
          const index = currentStack.indexOf(Buffer.from(data).toString("hex"));
          if (index > -1) {
            currentStack.splice(index, 1);
          }
          console.log(currentStack);
          //remove from stack display
          stackEl.remove();
          //update locking script
          const hex = bsv.Script.fromASM(currentStack.join(" ")).toHex();
          const asm = bsv.Script.fromASM(currentStack.join(" ")).toASM();
          document.getElementById("hex").innerHTML = hex;
          document.getElementById("asm").innerHTML = asm;
          document.getElementById("binary").innerHTML = hexToBinary(hex);
        });
      };
      const addPubKeyHash = () => {
        const receiever = document.getElementById("receiver").value;
        const address = bsv.Address.fromString(receiever);
        const pubKeyHash = address.hashBuffer.toString("hex");
        currentStack.push(pubKeyHash);
        const hex = bsv.Script.fromASM(currentStack.join(" ")).toHex();
        const asm = bsv.Script.fromASM(currentStack.join(" ")).toASM();
        document.getElementById("hex").innerHTML = hex;
        document.getElementById("asm").innerHTML = asm;
        document.getElementById("binary").innerHTML = hexToBinary(hex);
        console.log(hex);
        const stackEl = document.createElement("div");
        stackEl.innerHTML = pubKeyHash;
        document.getElementById("stack").appendChild(stackEl);
        stackEl.addEventListener("click", () => {
          //remove from stack
          const index = currentStack.indexOf(pubKeyHash);
          if (index > -1) {
            currentStack.splice(index, 1);
          }
          //remove from stack display
          stackEl.remove();
          console.log(currentStack);

          //update locking script
          const hex = bsv.Script.fromASM(currentStack.join(" ")).toHex();
          const asm = bsv.Script.fromASM(currentStack.join(" ")).toASM();
          document.getElementById("hex").innerHTML = hex;
          document.getElementById("asm").innerHTML = asm;
          document.getElementById("binary").innerHTML = hexToBinary(hex);
        });
      };

      //add pubkey
      const addPubKey = () => {
        //from keys
        const privateKey = bsv.PrivateKey.fromString(keys.privateKey);
        const pubKey = bsv.PublicKey.fromPrivateKey(privateKey);
        currentStack.push(pubKey.toString());
        console.log(currentStack);
        const hex = bsv.Script.fromASM(currentStack.join(" ")).toHex();
        const asm = bsv.Script.fromASM(currentStack.join(" ")).toASM();
        document.getElementById("hex").innerHTML = hex;
        document.getElementById("asm").innerHTML = asm;
        document.getElementById("binary").innerHTML = hexToBinary(hex);
        console.log(hex);
        const stackEl = document.createElement("div");
        stackEl.innerHTML = pubKey;
        document.getElementById("stack").appendChild(stackEl);
        stackEl.addEventListener("click", () => {
          //remove from stack
          const index = currentStack.indexOf(pubKey);
          if (index > -1) {
            currentStack.splice(index, 1);
          }
          //remove from stack display
          stackEl.remove();
          console.log(currentStack);

          //update locking script
          const hex = bsv.Script.fromASM(currentStack.join(" ")).toHex();
          const asm = bsv.Script.fromASM(currentStack.join(" ")).toASM();
          document.getElementById("hex").innerHTML = hex;
          document.getElementById("asm").innerHTML = asm;
          document.getElementById("binary").innerHTML = hexToBinary(hex);
        });
      };

      document.getElementById("addPubKey").addEventListener("click", () => {
        addPubKey();
      });
      const addHashData = () => {
        let data = document.getElementById("data").value;
        if (!data) {
          alert("Please enter data");
          return;
        }
        data = data.trim();
        const hash = bsv.crypto.Hash.sha256(Buffer.from(data)).toString("hex");
        console.log(hash);
        currentStack.push(hash);
        console.log(currentStack);
        const hex = bsv.Script.fromASM(currentStack.join(" ")).toHex();
        const asm = bsv.Script.fromASM(currentStack.join(" ")).toASM();
        document.getElementById("hex").innerHTML = hex;
        document.getElementById("asm").innerHTML = asm;
        document.getElementById("binary").innerHTML = hexToBinary(hex);
        console.log(hex);
        const alertCheck = document.getElementById("alertCheck").checked;
        if (
          (alertCheck && currentStack.length === 0) || //if alert check is true, don't alert
          (alertCheck &&
            !currentStack[currentStack.length - 1].includes("OP_PUSHDATA"))
        ) {
          let opCode = "OP_PUSHDATA1";

          console.log(length);
          // must be less than 4GB
          if (length < 76) {
            opCode = "OP_PUSHDATA1";
            alert(
              `Data length is ${length} bytes, consider preceding this data with OP_PUSHDATA1`
            );
          } else if (length < 256) {
            opCode = "OP_PUSHDATA2";
            alert(
              `Data length is ${length} bytes, consider preceding this data with OP_PUSHDATA2`
            );
            // 4GB
          } else if (length > 256 && length < 4294967296) {
            opCode = "OP_PUSHDATA4";
            alert(
              `Data length is ${length} bytes, consider preceding this data with OP_PUSHDATA4`
            );
          } else {
            alert("File too large");
            return;
          }
        }
        const stackEl = document.createElement("div");
        stackEl.innerHTML = hash;
        document.getElementById("stack").appendChild(stackEl);
        stackEl.addEventListener("click", () => {
          //remove from stack
          const index = currentStack.indexOf(hash);
          if (index > -1) {
            currentStack.splice(index, 1);
          }
          console.log(currentStack);
          //remove from stack display
          stackEl.remove();
          //update locking script
          const hex = bsv.Script.fromASM(currentStack.join(" ")).toHex();
          const asm = bsv.Script.fromASM(currentStack.join(" ")).toASM();
          document.getElementById("hex").innerHTML = hex;
          document.getElementById("asm").innerHTML = asm;
          document.getElementById("binary").innerHTML = hexToBinary(hex);
        });
      };
      // add double hash data
      const addDoubleHashData = () => {
        let data = document.getElementById("data").value;
        if (!data) {
          alert("Please enter data");
          return;
        }
        data = data.trim();
        // double hash with hash256
        const doubleHash = bsv.crypto.Hash.sha256sha256(
          Buffer.from(data)
        ).toString("hex");
        console.log(doubleHash);
        currentStack.push(doubleHash);

        const hex = bsv.Script.fromASM(currentStack.join(" ")).toHex();
        const asm = bsv.Script.fromASM(currentStack.join(" ")).toASM();
        document.getElementById("hex").innerHTML = hex;
        document.getElementById("asm").innerHTML = asm;
        document.getElementById("binary").innerHTML = hexToBinary(hex);
        console.log(hex);
        const alertCheck = document.getElementById("alertCheck").checked;
        if (
          (alertCheck && currentStack.length === 0) || //if alert check is true, don't alert
          (alertCheck &&
            !currentStack[currentStack.length - 1].includes("OP_PUSHDATA"))
        ) {
          let opCode = "OP_PUSHDATA1";

          console.log(length);
          // must be less than 4GB
          if (length < 76) {
            opCode = "OP_PUSHDATA1";
            alert(
              `Data length is ${length} bytes, consider preceding this data with OP_PUSHDATA1`
            );
          } else if (length < 256) {
            opCode = "OP_PUSHDATA2";
            alert(
              `Data length is ${length} bytes, consider preceding this data with OP_PUSHDATA2`
            );
            // 4GB
          } else if (length > 256 && length < 4294967296) {
            opCode = "OP_PUSHDATA4";
            alert(
              `Data length is ${length} bytes, consider preceding this data with OP_PUSHDATA4`
            );
          } else {
            alert("File too large");
            return;
          }
        }
        const stackEl = document.createElement("div");
        stackEl.innerHTML = doubleHash;
        document.getElementById("stack").appendChild(stackEl);
        stackEl.addEventListener("click", () => {
          //remove from stack
          const index = currentStack.indexOf(doubleHash);
          if (index > -1) {
            currentStack.splice(index, 1);
          }
          console.log(currentStack);
          //remove from stack display
          stackEl.remove();
          //update locking script
          const hex = bsv.Script.fromASM(currentStack.join(" ")).toHex();
          const asm = bsv.Script.fromASM(currentStack.join(" ")).toASM();
          document.getElementById("hex").innerHTML = hex;
          document.getElementById("asm").innerHTML = asm;
          document.getElementById("binary").innerHTML = hexToBinary(hex);
        });
      };
      document
        .getElementById("addDoubleHashData")
        .addEventListener("click", () => {
          addDoubleHashData();
        });
      //add p2pkh
      document.getElementById("p2pkh").addEventListener("click", () => {
        //OP_DUP OP_HASH160 <Public Key Hash> OP_EQUALVERIFY OP_CHECKSIG
        const recipientAddress = document.getElementById("receiver").value;
        const address = bsv.Address.fromString(recipientAddress);
        const pubKeyHash = address.hashBuffer.toString("hex");
        currentStack.push("OP_DUP");
        currentStack.push("OP_HASH160");
        currentStack.push(pubKeyHash);
        currentStack.push("OP_EQUALVERIFY");
        currentStack.push("OP_CHECKSIG");
        const hex = bsv.Script.fromASM(currentStack.join(" ")).toHex();
        const asm = bsv.Script.fromASM(currentStack.join(" ")).toASM();
        document.getElementById("hex").innerHTML = hex;
        document.getElementById("asm").innerHTML = asm;
        document.getElementById("binary").innerHTML = hexToBinary(hex);
        console.log(hex);
        //add all items to stack display
        currentStack.forEach((item) => {
          const stackEl = document.createElement("div");
          stackEl.innerHTML = item;
          document.getElementById("stack").appendChild(stackEl);
          stackEl.addEventListener("click", () => {
            //remove from stack
            const index = currentStack.indexOf(item);
            if (index > -1) {
              currentStack.splice(index, 1);
            }
            console.log(currentStack);
            //remove from stack display
            stackEl.remove();
            //update locking script
            const hex = bsv.Script.fromASM(currentStack.join(" ")).toHex();
            const asm = bsv.Script.fromASM(currentStack.join(" ")).toASM();
            document.getElementById("hex").innerHTML = hex;
            document.getElementById("asm").innerHTML = asm;
            document.getElementById("binary").innerHTML = hexToBinary(hex);
          });
        });
      });

      document.getElementById("addOpCode").addEventListener("click", addOpCode);
      document.getElementById("addData").addEventListener("click", addData);
      document
        .getElementById("addHashData")
        .addEventListener("click", addHashData);

      document
        .getElementById("addPubKeyHash")
        .addEventListener("click", addPubKeyHash);

      const broadcast = document.getElementById("genBroadcast");
      broadcast.addEventListener("click", async () => {
        try {
          const tx = document.getElementById("lockResults").innerHTML;
          const txid = await broadcastTx(tx);
          //add txid to lockresults
          document.getElementById(
            "lockResults"
          ).innerHTML = `Broadcasted: <a href="https://whatsonchain.com/tx/${txid}" target="_blank">${txid}</a>`;
          console.log(txid);
          alert("Broadcasted");
        } catch (err) {
          console.log(err);
          alert("Error");
        }
      });

      const buildLockingScript = async () => {
        redeemScriptCheck = document.getElementById("redeemCheck").checked;
        const address = document.getElementById("address").innerHTML;
        const addy = bsv.Address.fromString(address);
        const nLocktime = parseInt(document.getElementById("nLocktime").value);
        let utxos = [];

        const tx = new bsv.Transaction();
        //nlocktime
        // if (nLocktime > 0) {
        //   tx.nLockTime = nLocktime;
        // }
        let txHex = "";
        if (!redeemScriptCheck) {
          utxos = await getUtxosWhatsOnchain(addy);
          console.log(address, utxos);
          utxos = utxos.filter((utxo) => utxo.satoshis > 1);
          tx.from(utxos);
          console.log("locking script", redeemScriptCheck);
          const amount = document.getElementById("amount").value;
          console.log(amount);
          const lock = bsv.Script.fromASM(currentStack.join(" "));
          tx.addOutput(
            new bsv.Transaction.Output({
              script: lock,
              satoshis: parseInt(amount),
            })
          );
          // get preimage of utxo[0]
          const preimage = bsv.Transaction.sighash
            .sighashPreimage(
              tx,
              //sighash type
              sighashType,
              //input
              0,
              utxos[0].script,
              //amount in BN
              new bsv.crypto.BN(amount),
              //flags
              bsv.Script.Interpreter.SCRIPT_ENABLE_SIGHASH_FORKID
            )
            .toString("hex");

          currentPreimage = Buffer.from(preimage, "hex");
          console.log(preimage);
          document.getElementById(
            "preimage"
          ).innerHTML = `Preimage: ${preimage}`;
          tx.change(addy);

          tx.feePerKb(15);
          tx.sign(keys.privateKey);
          console.log(tx);
          txHex = tx.toString();
        } else {
          utxos = currentUtxos;
          console.log(address, utxos);
          tx.from(utxos);
          console.log("redeem script");
          // set input script to current stack
          if (currentStack.length !== 0) {
            const redeemScript = bsv.Script.fromASM(currentStack.join(" "));
            tx.inputs[0].setScript(redeemScript);
          }
          //add currentutxos amount to recipient
          const amount = currentUtxos[0].satoshis;
          tx.addOutput(
            new bsv.Transaction.Output({
              script: bsv.Script.buildPublicKeyHashOut(address),
              satoshis: amount > 1 ? amount - 1 : amount,
            })
          );
          txHex = tx.toString();
        }

        //add to broadcast binary
        document.getElementById("binary").innerHTML = txHex;
        document.getElementById("lockResults").innerHTML = txHex;
        document.getElementById("lockResults").addEventListener("click", () => {
          navigator.clipboard.writeText(txHex);
          alert("Copied to clipboard");
        });
        //scroll to results
        document.getElementById("lockResults").scrollIntoView();
        //display broadcast button
        document.getElementById("genBroadcast").style.display = "block";
      };

      document.getElementById("broadcast").addEventListener("click", () => {
        buildLockingScript();
      });
      const getTxInfo = async (txid) => {
        const response = await fetch(
          // whatsOnChain
          `https://api.whatsonchain.com/v1/bsv/main/tx/${txid}`
        );
        const res = await response.json();
        return res;
      };
      const getTxHex = async (txid) => {
        const response = await fetch(
          // whatsOnChain
          `https://api.whatsonchain.com/v1/bsv/main/tx/${txid}/hex`
        );
        const res = await response.text();
        return res;
      };

      // add signature to current preimage
      const addSignature = async () => {
        const privateKey = keys.privateKey;
        if (!currentPreimage) {
          alert("Please load a transaction to sign");
          return;
        }

        //convert currentPreimage from hex to 32 byte hashbuffer
        const hashBuffer = bsv.crypto.Hash.sha256sha256(currentPreimage);
        const privkey = bsv.PrivateKey.fromString(privateKey);
        const sig = bsv.crypto.ECDSA.sign(hashBuffer, privkey, "little").set({
          nhashtype: sighashType,
        });
        const sigHex = sig.toString();
        console.log(sigHex);
        currentStack.push(sigHex);
        const hex = bsv.Script.fromASM(currentStack.join(" ")).toHex();
        const asm = bsv.Script.fromASM(currentStack.join(" ")).toASM();
        document.getElementById("hex").innerHTML = hex;
        document.getElementById("asm").innerHTML = asm;
        document.getElementById("binary").innerHTML = hexToBinary(hex);
        console.log(hex);
        const stackEl = document.createElement("div");
        stackEl.innerHTML = sig;
        document.getElementById("stack").appendChild(stackEl);
        stackEl.addEventListener("click", () => {
          //remove from stack
          const index = currentStack.indexOf(sig);
          if (index > -1) {
            currentStack.splice(index, 1);
          }
          console.log(currentStack);
          //remove from stack display
          stackEl.remove();
          //update locking script
          const hex = bsv.Script.fromASM(currentStack.join(" ")).toHex();
          const asm = bsv.Script.fromASM(currentStack.join(" ")).toASM();
          document.getElementById("hex").innerHTML = hex;
          document.getElementById("asm").innerHTML = asm;
          document.getElementById("binary").innerHTML = hexToBinary(hex);
        });
      };

      document
        .getElementById("addSignature")
        .addEventListener("click", addSignature);

      //sighash selector

      document
        .getElementById("sighashSelect")
        .addEventListener("change", (e) => {
          e.preventDefault();
          console.log(e.target.value);
          const result = e.target.value;
          if (result != "null") {
            sighashType = `bsv.crypto.Signature.${result} | bsv.crypto.Signature.SIGHASH_FORKID;`;
          }
          console.log(sighashType);
        });

      const redeemLock = async () => {
        // use current opcode stack for users unlock script
        const txid = document.getElementById("txidInput").value;
        // const txInfo = await getTxInfo(txid);
        const txHex = await getTxHex(txid);
        // console.log(txInfo);
        console.log(txHex);
        const txinfo = bsv.Transaction(txHex);
        const lockingScript = txinfo.outputs[0].script;
        //add to current utxos
        const tx = new bsv.Transaction();
        tx.from({
          txid: txid,
          vout: 0,
          script: lockingScript,
          satoshis: txinfo.outputs[0].satoshis,
        });

        console.log(tx);
        sighashType =
          bsv.crypto.Signature.SIGHASH_NONE |
          bsv.crypto.Signature.SIGHASH_FORKID;
        const preimage = bsv.Transaction.sighash
          .sighashPreimage(
            tx,
            //sighash single
            sighashType,
            //input
            0,
            lockingScript,
            //amount in BN
            new bsv.crypto.BN(txinfo.outputs[0].satoshis),
            //flags
            bsv.Script.Interpreter.SCRIPT_ENABLE_SIGHASH_FORKID
          )
          .toString("hex");
        //add preimage to text area
        document.getElementById("data").value = preimage;

        // scroll to data
        currentPreimage = Buffer.from(preimage, "hex");
        document.getElementById("data").scrollIntoView();
        alert(
          "transaction loaded as current utxo, preimage added to data to use in unlocking script if needed"
        );
        currentUtxos.push({
          txid: txid,
          vout: 0,
          script: lockingScript.toHex(),
          satoshis: txinfo.outputs[0].satoshis,
          preimage: preimage.toString("hex"),
        });
      };
      document.getElementById("redeem").addEventListener("click", redeemLock);
      //import mnemonic

      //addeventlistener for file upload and change add data button to add file
      document.getElementById("file").addEventListener("change", () => {
        document.getElementById("addData").innerHTML = "Add File Data";
        document.getElementById("addData").style.backgroundColor = "red";
      });

      //clear all inputs
      currentStack = [];
      document.getElementById("stack").innerHTML = "";
      document.getElementById("hex").innerHTML = "";
      document.getElementById("asm").innerHTML = "";
      document.getElementById("binary").innerHTML = "";
      document.getElementById("lockResults").innerHTML = "";
      document.getElementById("genBroadcast").style.display = "none";
      document.getElementById("data").value = "";
      document.getElementById("file").value = "";
      document.getElementById("amount").value = "1";
    </script>
  </body>
</html>
